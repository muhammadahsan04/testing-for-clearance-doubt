import { useState, useEffect } from "react";
import ItemCategoryTable from "../../../components/ItemCategoryTable";
import axios from "axios";
import { toast } from "react-toastify";
import { hasPermission } from "../sections/CoreSettings";

// Helper function to get auth token
const getAuthToken = () => {
  let token = localStorage.getItem("token");
  if (!token) {
    token = sessionStorage.getItem("token");
  }
  return token;
};

// getUserRole function add
const getUserRole = () => {
  let role = localStorage.getItem("role");
  if (!role) {
    role = sessionStorage.getItem("role");
  }
  return role;
};

interface Column {
  header: string;
  accessor: string;
  type?: "text" | "image" | "status" | "actions";
}

export default function AllItemCategory() {
  const [itemsData, setItemsData] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedUser, setSelectedUser] = useState(null);

  const API_URL = import.meta.env.VITE_BASE_URL || "http://192.168.100.18:9000";

  // Permission variables add
  const userRole = getUserRole();
  const isAdmin = userRole === "Admin" || userRole === "SuperAdmin";
  const canDelete = isAdmin || hasPermission("Core Setting", "delete");
  const canUpdate = isAdmin || hasPermission("Core Setting", "update");
  // Fetch all items
  const fetchAllItems = async () => {
    try {
      setLoading(true);
      const token = getAuthToken();

      if (!token) {
        toast.error("Authentication token not found. Please login again.");
        return;
      }

      const response = await axios.get(
        `${API_URL}/api/abid-jewelry-ms/getAllItems`,
        {
          headers: {
            "x-access-token": token,
          },
        }
      );

      if (response.data.success) {
        // Transform the data to match table format
        const transformedData = response.data.data.map(
          (item: any, index: number) => ({
            _id: item._id,
            sno: String(index + 1).padStart(2, "0"),
            sku: `${item.prefixId?.prefixName || ""}-${
              item.autoGenerated || ""
            }`,
            Barcode: item.barcode || "",
            unitType: item.unitType || "",
            categoryImage: `${API_URL}${item.itemImage}` || "",
            productFor: Array.isArray(item.productFor)
              ? item.productFor.join(", ")
              : item.productFor || "",
            category: item.category?.name || "", // ✅ This is correct - extracting name
            subCategory: item.subCategory?.name || "", // ✅ This is correct - extracting name
            style: item.style?.name || "",
            goldCTG: item.goldCategory?.name || "",
            diamondWeight: item.diamondWeight || "",
            goldWeight: item.goldWeight || "",
            length: item.length || "",
            mm: item.mm || "",
            size: item.size || "",
            searchTag: Array.isArray(item.searchTag)
              ? item.searchTag.join(", ")
              : item.searchTag || "",
            status: item.status || "Active",
          })
        );

        setItemsData(transformedData);
      } else {
        toast.error("Failed to fetch items");
      }
    } catch (error) {
      console.error("Error fetching items:", error);
      if (axios.isAxiosError(error)) {
        if (!error.response) {
          toast.error("Network error. Please check your internet connection.");
        } else {
          toast.error(error.response.data.message || "Failed to fetch items");
        }
      } else {
        toast.error("An unexpected error occurred while fetching items");
      }
    } finally {
      setLoading(false);
    }
  };

  // Delete item function
  const handleDeleteItem = async (item: any) => {
    if (!canDelete) {
      toast.error("You don't have permission to delete items");
      return;
    }

    if (!item || !item._id) {
      toast.error("Invalid item selected for deletion");
      return;
    }

    try {
      const token = getAuthToken();
      if (!token) {
        toast.error("Authentication token not found. Please login again.");
        return;
      }

      const response = await axios.delete(
        `${API_URL}/api/abid-jewelry-ms/deleteItem/${item._id}`,
        {
          headers: {
            "x-access-token": token,
          },
        }
      );

      if (response.data.success) {
        toast.success("Item deleted successfully!");
        fetchAllItems(); // Refresh the list
      } else {
        toast.error(response.data.message || "Failed to delete item");
      }
    } catch (error) {
      console.error("Error deleting item:", error);
      if (axios.isAxiosError(error)) {
        if (!error.response) {
          toast.error("Network error. Please check your internet connection.");
        } else {
          toast.error(error.response.data.message || "Failed to delete item");
        }
      } else {
        toast.error("An unexpected error occurred while deleting item");
      }
    }
  };

  useEffect(() => {
    fetchAllItems();
  }, []);

  const columns: Column[] = [
    { header: "S.No", accessor: "sno", type: "text" },
    { header: "SKU", accessor: "sku", type: "text" },
    { header: "Barcode", accessor: "Barcode", type: "text" },
    { header: "Unit Type", accessor: "unitType", type: "text" },
    { header: "Image", accessor: "categoryImage", type: "image" },
    { header: "Product For", accessor: "productFor", type: "text" },
    { header: "Category", accessor: "category", type: "text" },
    { header: "Sub Category", accessor: "subCategory", type: "text" },
    { header: "Style", accessor: "style", type: "text" },
    // { header: "Gold Ctg", accessor: "goldCTG", type: "text" },
    // { header: "Diamond Weight", accessor: "diamondWeight", type: "text" },
    // { header: "Gold Weight", accessor: "goldWeight", type: "text" },
    // { header: "Length", accessor: "length", type: "text" },
    // { header: "MM", accessor: "mm", type: "text" },
    // { header: "Size", accessor: "size", type: "text" },
    { header: "Search Tag", accessor: "searchTag", type: "text" },
    { header: "Actions", accessor: "actions", type: "actions" },
  ];

  return (
    <div className="w-full mx-auto px-3 py-6 sm:px-4 md:px-6 xl:px-8 xl:py-6">
      {loading ? (
        <div className="text-center flex justify-center min-h-screen items-center">
          <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
        </div>
      ) : (
        <>
          <h1 className="text-2xl font-semibold text-gray-800 mb-6">
            All Item Categories
          </h1>

          <ItemCategoryTable
            allItem={true}
            className=""
            tableDataAlignment="zone"
            columns={columns}
            data={itemsData}
            tableTitle="All Item Categories"
            searchable={true}
            filterByStatus={true}
            canUpdate={canUpdate}
            canDelete={canDelete}
            onEdit={(row: any) => setSelectedUser(row)}
            onDelete={handleDeleteItem} // ✅ Now properly connected to the delete function
          />
        </>
      )}
    </div>
  );
}
